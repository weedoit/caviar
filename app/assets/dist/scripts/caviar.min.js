// Application namespace
var App;
(function (App) {
    App.foo = 1;
})(App || (App = {}));

/**
 * Module with some utils
 * @module Caviar
 * @author Bruno Ziiê <http://github.com/brunoziie/>
 */
var Caviar;
(function (Caviar) {
    var __globals = {}, isWP, getNavigatorObject;
    // Checks if application are running on Windows Phone
    isWP = window.location.href.indexOf('x-wmapp0:') >= 0;
    /**
     * Wrapper to avoid TypeScript error
     **/
    getNavigatorObject = function () {
        return navigator;
    };
    /**
     * Main element
     * @type {Node}
     */
    Caviar.contentBox = document.querySelector('.caviar-stage-container');
    /**
     * Merge multiples configs with previous configs set.
     * @param {Object} list Object with key-value pair configs list
     */
    function merge(origin, target) {
        var hasProp = {}.hasOwnProperty, item;
        for (item in origin) {
            if (origin.hasOwnProperty(item)) {
                target[item] = origin[item];
            }
        }
        return target;
    }
    Caviar.merge = merge;
    /**
     * Checks if is as function
     * @param  {Mixed}  arg
     * @return {Boolean}
     */
    function isFunction(arg) {
        return typeof arg === 'function';
    }
    Caviar.isFunction = isFunction;
    /**
     * Checks if application are running on Windows Phone
     * @return {Boolean} [description]
     */
    function runningOnWP() {
        return isWP;
    }
    Caviar.runningOnWP = runningOnWP;
    function matchSelector(element, selector) {
        var ref = document.body, matches = ref.matches || ref.webkitMatchesSelector;
        return matches.call(element, selector);
    }
    Caviar.matchSelector = matchSelector;
    /**
     * Exit from app
     */
    function exit() {
        var nav = getNavigatorObject();
        if (nav.app) {
            return nav.app.exitApp();
        }
        else if (nav.device) {
            return nav.device.exitApp();
        }
        else {
            return console.log('[Caviar] Application supposed to be ended');
        }
    }
    Caviar.exit = exit;
    var globals;
    (function (globals) {
        /**
         * Get a variable of application global scope
         * @param {String} key
         */
        function get(key) {
            return __globals[key] || null;
        }
        globals.get = get;
        /**
         * Add/update a application global scope variable
         * @param {String} key
         * @param {Mixed} value
         */
        function set(key, value) {
            return __globals[key] = value;
        }
        globals.set = set;
    })(globals = Caviar.globals || (Caviar.globals = {}));
})(Caviar || (Caviar = {}));

/// <reference path="Caviar.ts" />
var Caviar;
(function (Caviar) {
    var configsSet;
    configsSet = {
        /**
         * App version
         * @type {String}
         */
        version: '0.0.1',
        /**
         * Enable some debug features
         * @type {String}
         */
        debug: true,
        /**
         * Define if application uses database
         * @type {Boolean}
         */
        useDatabase: false,
        /**
         * Define id application has sidebar menu
         * @type {Boolean}
         */
        hasSidebarMenu: true,
        /**
         * Navbar height (pixels)
         * @type {Integer}
         */
        navbarHeight: 50
    };
    /**
     * Application configs
     * @module Caviar
     * @class Config
     * @author Bruno Ziiê <http://github.com/brunoziie/>
     */
    var Config = (function () {
        function Config() {
        }
        /**
         * Get a config value
         * @param  {String} key Config name
         * @return {Mixed}      Config value
         */
        Config.get = function (key) {
            return configsSet[key];
        };
        /**
         * Set a config using key and value
         * @param {String} key   Config name
         * @param {Mixed}  value Config value
         */
        Config.set = function (key, value) {
            if (typeof key === 'object') {
                configsSet = Caviar.merge(key, configsSet);
            }
            else {
                configsSet[key] = value;
            }
        };
        return Config;
    })();
    Caviar.Config = Config;
})(Caviar || (Caviar = {}));

var Caviar;
(function (Caviar) {
    /**
     * Represents a intention to go to a other controller
     * @module Caviar
     * @class Intent
     * @author Bruno Ziiê <http://github.com/brunoziie/>
     */
    var Intent = (function () {
        /**
         * Constructor
         * @param {Object} element DOM Element that calls a
         *                         intent or string with controller name
         */
        function Intent(element) {
            /**
             * Controller that will be called
             * @type {string}
             */
            this.controller = null;
            /**
             * Controller instance Id
             * @type {string}
             */
            this.controllerInstanceId = null;
            /**
             * Optional data to controller
             * @type {Object}
             */
            this.data = null;
            /**
             * If true, returns data for previous screen instance
             * @type {Boolean}
             */
            this.forResult = false;
            /**
             * Transition effect
             * @type {Object}
             */
            this.transition = 'show';
            /**
             * Element that was invoked intent
             * @type {Object}
             */
            this.caller = null;
            if (element !== undefined) {
                if (typeof element === 'string') {
                    this.parseControllerName(element);
                }
                else if (typeof element === 'object') {
                    this.parseIntentElement(element);
                    this.caller = element;
                }
            }
            this.data = {};
        }
        /**
         * Mount a intent from a element
         * @param  {Object} element DOM Element that calls a intent
         */
        Intent.prototype.parseIntentElement = function (element) {
            var intentData, intentForResult, transition;
            intentData = element.getAttribute('intent-data');
            intentForResult = element.getAttribute('intent-forResults');
            transition = element.getAttribute('intent-transition');
            if (intentData !== null && (intentData.charAt(0) === '[' || intentData.charAt(0) === '{')) {
                this.data = JSON.stringify(intentData);
            }
            else {
                this.data = {};
            }
            this.transition = (transition !== null) ? transition : 'show';
            this.forResult = (intentForResult !== null && intentForResult === 'true') ? true : false;
            this.parseControllerName(element.getAttribute('intent'));
        };
        /**
         * Parse controller name
         */
        Intent.prototype.parseControllerName = function (intentPath) {
            this.controller = intentPath.replace(/^([a-z])|_([a-z])/g, function ($1) {
                return $1.toUpperCase();
            }).replace(/(\s|_)/g, '') + 'Controller';
        };
        return Intent;
    })();
    Caviar.Intent = Intent;
})(Caviar || (Caviar = {}));

/// <reference path="Intent.ts" />
var Caviar;
(function (Caviar) {
    var colletion = [];
    /**
     * Stores started intents history
     * @module Caviar.IntentHistory
     * @author Bruno Ziiê <http://github.com/brunoziie/>
     */
    var IntentHistory;
    (function (IntentHistory) {
        /**
         * Add an intent in history
         * @param {Intent} intent
         */
        function add(intent) {
            return colletion.push(intent);
        }
        IntentHistory.add = add;
        /**
         * Return current intent or null if not have intent started
         * @return {Intent}
         */
        function getCurrent() {
            return colletion[colletion.length - 1] || null;
        }
        IntentHistory.getCurrent = getCurrent;
        /**
         * Return previous intent or null if not exists
         * @return {Intent}
         */
        function getPrev() {
            return colletion[colletion.length - 2] || null;
        }
        IntentHistory.getPrev = getPrev;
        /**
         * Remove an intent from history
         * @param {Intent} intent
         */
        function remove(intent) {
            var index = colletion.indexOf(intent);
            if (index > -1) {
                colletion.splice(index, 1);
            }
        }
        IntentHistory.remove = remove;
        /**
         * Remove last intent of history
         * @return {Intent}
         */
        function removeLast() {
            return colletion.pop();
        }
        IntentHistory.removeLast = removeLast;
        /**
         * Returns full history
         * @return {Array}
         */
        function all() {
            return colletion;
        }
        IntentHistory.all = all;
        /**
         * Returns history length
         * @return {Number}
         */
        function count() {
            return colletion.length;
        }
        IntentHistory.count = count;
        /**
         * Clear intents history
         * @return {Array}
         */
        function clear() {
            return colletion = [];
        }
        IntentHistory.clear = clear;
        /**
         * Check if exists a prev intent on stack
         * @return {boolean}
         */
        function hasPrev() {
            return colletion.length > 1;
        }
        IntentHistory.hasPrev = hasPrev;
    })(IntentHistory = Caviar.IntentHistory || (Caviar.IntentHistory = {}));
})(Caviar || (Caviar = {}));

/// <reference path="defs/jquery/jquery.d.ts" />
/// <reference path="defs/velocity/velocity.d.ts" />
var Caviar;
(function (Caviar) {
    var RUNNING, STOPED, registeredAnimations, queue, addToQueue, processQueue, queueStatus;
    /**
     * Constants
     */
    RUNNING = 1;
    STOPED = 2;
    /**
     * Transitions Queue
     * @type {Array}
     */
    queue = [];
    /**
     * Queue status
     * @type {Number}
     */
    queueStatus = STOPED;
    /**
     * Transitions effects colletion
     * @type {Object}
     */
    registeredAnimations = {
        // All animations should to have "transitionIn" and "transitionOut" methods.
        //
        // The "transitionIn" method receive the view of the active controller as first
        // argument and the view of next controller as second argument.
        //
        // The "transitionOut" method too receive the view of active controller as first argument,
        // but the second argument receive the view of previous controller instead of.
        //
        // Both methods should return a sequence from VelocityJS.
        // (More about VelocityJS's sequence at: http://julian.com/research/velocity/#uiPack)
        show: {
            transitionIn: function ($active, $next) {
                return [
                    { e: $next, p: { opacity: 1 }, options: { duration: 1, easing: 'ease' } }
                ];
            },
            transitionOut: function ($active, $prev) {
                return [
                    { e: $prev, p: { opacity: 1 }, options: { duration: 1, easing: 'ease' } }
                ];
            }
        },
        slideLeft: {
            transitionIn: function ($active, $next) {
                return [
                    { e: $active, p: { scale: 0.9, opacity: 0.6 }, options: { duration: 150, easing: 'ease' } },
                    { e: $next, p: { translateX: [0, '100%'] }, options: { duration: 300, easing: 'ease' } }
                ];
            },
            transitionOut: function ($active, $prev) {
                return [
                    { e: $active, p: { translateX: ['100%', 0] }, options: { duration: 300, easing: 'ease' } },
                    { e: $prev, p: { scale: 1, opacity: 1 }, options: { duration: 150, easing: 'ease' } }
                ];
            }
        },
        slideUp: {
            transitionIn: function ($active, $next) {
                return [
                    { e: $active, p: { scale: 0.9, opacity: 0.6 }, options: { duration: 150, easing: 'ease' } },
                    { e: $next, p: { translateY: [0, '100%'] }, options: { duration: 300, easing: 'ease' } }
                ];
            },
            transitionOut: function ($active, $prev) {
                return [
                    { e: $active, p: { translateY: ['100%', 0] }, options: { duration: 300, easing: 'ease' } },
                    { e: $prev, p: { scale: 1, opacity: 1 }, options: { duration: 150, easing: 'ease' } }
                ];
            }
        }
    };
    /**
     * Add a transition animation to queue
     * @param {Array} sequence A VelocityJS sequence.
     */
    addToQueue = function (sequence) {
        queue.push(sequence);
        if (queue.length === 1 && queueStatus === STOPED) {
            processQueue();
        }
    };
    /**
     * Run the next transition in queue
     * @param {Function}
     */
    processQueue = function () {
        var seq = queue.shift();
        if (seq) {
            queueStatus = RUNNING;
            Velocity.RunSequence(seq);
        }
        else {
            if (queueStatus === RUNNING) {
                queueStatus = STOPED;
            }
        }
    };
    /**
     * Manage and executes transitions between controllers
     * @module Caviar.UITransitions
     * @author Bruno Ziiê <http://github.com/brunoziie/>
     */
    var UITransitions;
    (function (UITransitions) {
        /**
         * Register a new transition effect
         * @param  {String} name          Effect name
         * @param  {Array}  transitionIn  TransitionIn effect sequence
         * @param  {Array}  transitionOut TransitionOut effect sequence
         */
        function register(name, transitionIn, transitionOut) {
            registeredAnimations[name] = {
                transitionIn: transitionIn,
                transitionOut: transitionOut
            };
        }
        UITransitions.register = register;
        /**
         * Executes a transitionIn effect
         * @param  {Object}   active   DOMElement of active controller.
         * @param  {Object}   next     DOMElement of next controller.
         * @param  {String}   effect   Effect name.
         * @param  {Function} callback Callback called when all itens of sequence was done.
         */
        function transitionIn(active, next, effect, callback) {
            var $active, $next, animationSequence, lastAnimation, _cb;
            $active = $(active);
            $next = $(next);
            animationSequence = registeredAnimations[effect].transitionIn(active, next);
            lastAnimation = animationSequence[animationSequence.length - 1];
            _cb = (typeof lastAnimation.options.complete === 'function') ? lastAnimation.options.complete : function () {
            };
            // The callback of the last item of sequence is overloaded to
            // process the rest of queue and toogle some CSS classes in views
            lastAnimation.options.complete = function () {
                $active.removeClass('caviar-active').addClass('caviar-backgrounded').addClass('caviar-hidden');
                $next.removeClass('caviar-next').addClass('caviar-active');
                callback();
                _cb();
                processQueue();
            };
            addToQueue(animationSequence);
        }
        UITransitions.transitionIn = transitionIn;
        /**
         * Executes a transitionOut effect
         * @param  {Object}   active   DOMElement of active controller.
         * @param  {Object}   prev     DOMElement of prev controller.
         * @param  {String}   effect   Effect name.
         * @param  {Function} callback Callback called when all itens of sequence was done.
         */
        function transitionOut(active, prev, effect, callback) {
            var $active, $prev, animationSequence, lastAnimation, firstAnimation, _cb;
            $active = $(active);
            $prev = $(prev);
            animationSequence = registeredAnimations[effect].transitionOut($active, $prev);
            lastAnimation = animationSequence[animationSequence.length - 1];
            firstAnimation = animationSequence[0];
            _cb = (typeof lastAnimation.options.complete === 'function') ? lastAnimation.options.complete : function () {
            };
            firstAnimation.options.begin = function () {
                $prev.removeClass('caviar-hidden');
            };
            // The callback of the last item of sequence is overloaded to
            // process the rest of queue and toogle some CSS classes in views
            lastAnimation.options.complete = function () {
                $active.removeClass('caviar-active').addClass('caviar-dead');
                $prev.removeClass('caviar-backgrounded').addClass('caviar-active');
                callback();
                _cb();
                processQueue();
            };
            addToQueue(animationSequence);
        }
        UITransitions.transitionOut = transitionOut;
    })(UITransitions = Caviar.UITransitions || (Caviar.UITransitions = {}));
})(Caviar || (Caviar = {}));

/// <reference path="defs/handlebars/handlebars.d.ts" />
var Caviar;
(function (Caviar) {
    var View = (function () {
        /**
         * Constructor
         * @param {String} template Layout file content
         */
        function View(template) {
            /**
             * Layout file content
             * @type {String}
             */
            this.rawTemplate = null;
            /**
             * Handlebars template from layout
             * @type {Object}
             */
            this.template = null;
            /**
             * List of sections presents in layout
             * @type {Object}
             */
            this.sectionsTemplates = null;
            /**
             * Find and parse section in layout
             * @return {void}
             */
            this.parseSections = function () {
                var matches, name, rawTemplate, html, output = {};
                rawTemplate = this.rawTemplate.replace(/@section\('(.*)'\)/g, '<code class="caviar-section $1">').replace(/@endsection/g, '</code>');
                html = document.createElement('div');
                html.innerHTML = rawTemplate;
                matches = html.querySelectorAll('code');
                [].map.call(matches, function (i) {
                    name = i.classList[1];
                    output[name] = Handlebars.compile(i.innerHTML, { noEscape: true });
                    i.insertBefore(document.createComment('caviar-section-' + name), i.firstChild);
                    i.appendChild(document.createComment('end-caviar-section-' + name));
                });
                this.rawTemplate = html.innerHTML.replace(/<\/?!?(code)[^>]*>/g, '');
                this.sectionsTemplates = output;
            };
            this.rawTemplate = template;
            this.parseTemplate();
        }
        /**
         * Convert layout to handlerbar template
         * @return {void}
         */
        View.prototype.parseTemplate = function () {
            // Skip sections parse if has not section in layout.
            if (this.rawTemplate.indexOf('@section') >= 0) {
                this.parseSections();
            }
            this.template = Handlebars.compile(this.rawTemplate, { noEscape: true });
        };
        return View;
    })();
    Caviar.View = View;
})(Caviar || (Caviar = {}));

/// <reference path="defs/SectionNodes.ts" />
var Caviar;
(function (Caviar) {
    var stringToFragment;
    /**
     * A section is a area in the view that could be updated
     * @module Caviar
     * @class Section
     * @author Bruno Ziiê <http://github.com/brunoziie/>
     */
    var Section = (function () {
        /**
         * Constructor
         * @param {SectionNodes} refNodes Object with reference nodes of opening
         *                                 and closing of section.
         * @param {Function}      template Handlebars instance.
         */
        function Section(refNodes, template) {
            /**
             * Object with reference nodes of opening and closing of section.
             * @type {SectionNodes}
             */
            this.refNodes = null;
            /**
             * Handlebars instance of section template
             * @type {Function}
             */
            this.template = null;
            this.refNodes = refNodes;
            this.template = template;
        }
        /**
         * Add a content on end of section
         * @param {string} str HTML string with content
         * @return {void}
         */
        Section.prototype.append = function (str) {
            var nodes = this.refNodes, fragment = stringToFragment(str);
            nodes.opening.parentNode.insertBefore(fragment, nodes.closing);
        };
        /**
         * Add a content on top of section
         * @param {string} str HTML string with content
         * @return {void}
         */
        Section.prototype.prepend = function (str) {
            var nodes = this.refNodes, fragment = stringToFragment(str), next = nodes.opening.nextSibling, ref = (next !== nodes.closing) ? next : nodes.closing;
            nodes.opening.parentNode.insertBefore(fragment, ref);
        };
        /**
         * Update section content
         * @param {string} str HTML string with content or object with
         *                     data to render the original templare
         * @return {void}
         */
        Section.prototype.update = function (data) {
            var nodes = this.refNodes, parent = nodes.opening.parentNode, current = nodes.opening, fragment = stringToFragment((typeof data === 'string') ? data : this.template(data));
            while (current.nextSibling !== nodes.closing) {
                parent.removeChild(current.nextSibling);
            }
            parent.insertBefore(fragment, nodes.closing);
        };
        /**
         * Render the section template
         * @param  {Object} data Data to render the template
         * @return {string}      Rendered HTML string
         */
        Section.prototype.render = function (data) {
            return this.template(data);
        };
        return Section;
    })();
    Caviar.Section = Section;
    /**
     * Convert from string to DocumentFragment
     * @param {string} string HTML String
     */
    stringToFragment = function (str) {
        var el = document.createElement('body'), fragment = document.createDocumentFragment(), currentNode;
        el.innerHTML = str;
        while (currentNode = el.firstChild) {
            fragment.appendChild(currentNode);
        }
        return fragment;
    };
})(Caviar || (Caviar = {}));

/// <reference path="Section.ts" />
/// <reference path="View.ts" />
/// <reference path="defs/SectionCommentNode.ts" />
var Caviar;
(function (Caviar) {
    var findMarkupCommentsNodes;
    /**
     * Represents a view on stage
     * @module Caviar
     * @class StagedView
     * @author Bruno Ziiê <http://github.com/brunoziie/>
     */
    var StagedView = (function () {
        /**
         * Constructor
         * @param {View}    viewObj       View object instance
         * @param {Element} stagedElement View element on stage
         */
        function StagedView(viewObj, stagedElement) {
            /**
             * View object
             * @type {View}
             */
            this.view = null;
            /**
             * View element on stage
             * @type {Element}
             */
            this.element = null;
            /**
             * Object with list of sections presents in the view
             * @type {Object}
             */
            this.sections = null;
            this.view = viewObj;
            this.element = stagedElement;
            this.sections = {};
            this.attachSections();
        }
        /**
         * Returns view element
         * @return {Element}
         */
        StagedView.prototype.getElement = function () {
            return this.element;
        };
        /**
         * Find all sections in view element
         */
        StagedView.prototype.attachSections = function () {
            this.sections = this.parseSections();
        };
        /**
         * Parse sections in view
         * @return {Object} Object with list of sections presents in the view
         */
        StagedView.prototype.parseSections = function () {
            var root = this.element, comments = findMarkupCommentsNodes(root), len = comments.length, openingNodes = [], commentsObj = {}, sections = {}, openingNodesLen, currentOpeningNode, current, closingNode, name, x, y;
            for (x = 0; x < len; x += 1) {
                current = comments[x];
                if (current.type === 'opening') {
                    openingNodes.push(current);
                }
                commentsObj[current.data] = current;
            }
            openingNodesLen = openingNodes.length;
            for (y = 0; y < openingNodesLen; y += 1) {
                currentOpeningNode = openingNodes[y];
                name = currentOpeningNode.data.replace('caviar-section-', '');
                closingNode = commentsObj['end-' + currentOpeningNode.data];
                if (!closingNode) {
                    throw new Error('Section "' + name + '" was\'nt closed');
                }
                sections[name] = new Caviar.Section({
                    opening: currentOpeningNode.node,
                    closing: closingNode.node
                }, this.view.sectionsTemplates[name]);
            }
            return sections;
        };
        StagedView.COMMENT_NODE = 8;
        return StagedView;
    })();
    Caviar.StagedView = StagedView;
    /**
     * Find section markup nodes
     * @param  {Node} root Root node
     * @return {Array<SectionCommentNode>}
     */
    findMarkupCommentsNodes = function (root) {
        var len = root.childNodes.length, comments = [], currentNode, currentNodeData, x;
        for (x = 0; x < len; x += 1) {
            currentNode = root.childNodes[x];
            currentNodeData = currentNode.data;
            if (currentNode.nodeType === StagedView.COMMENT_NODE) {
                if (currentNodeData.indexOf('caviar-section') >= 0) {
                    comments.push({
                        type: (currentNodeData.indexOf('end') === 0) ? 'closing' : 'opening',
                        data: currentNode.data,
                        node: currentNode
                    });
                }
            }
            else if (currentNode.childNodes.length > 0) {
                comments = comments.concat(findMarkupCommentsNodes(currentNode));
            }
        }
        return comments;
    };
})(Caviar || (Caviar = {}));

/// <reference path="Caviar.ts" />
/// <reference path="UITransitions.ts" />
/// <reference path="View.ts" />
/// <reference path="StagedView.ts" />
/// <reference path="Intent.ts" />
var Caviar;
(function (Caviar) {
    /**
     * Manage transitions and view elements
     * @module Caviar.UIManager
     * @author Bruno Ziiê <http://github.com/brunoziie/>
     */
    var UIManager;
    (function (UIManager) {
        var UID = 0;
        /**
         * Render a view template and insert it into DOM
         * @param  {View}       uid        View object of layout
         * @param  {Object}     layoutData Data to render layout template
         * @return {StagedView}            StagedView object
         */
        function addViewToStage(view, data) {
            var el, viewId;
            viewId = (UID += 1) + '_ci';
            el = document.createElement('div');
            el.setAttribute('id', viewId);
            el.setAttribute('class', 'caviar-ui-controler-instance caviar-next');
            el.innerHTML = view.template(data);
            Caviar.contentBox.appendChild(el);
            return new Caviar.StagedView(view, el);
        }
        UIManager.addViewToStage = addViewToStage;
        /**
         * Transition in between controllers
         * @param  {Function} callback Transition end callback
         * @return {void}
         */
        function transitionIn(activeIntent, nextIntent, callback) {
            var cb = callback || function () {
            }, currentView, nextView;
            currentView = Caviar.ControllersInstanceManager.get(activeIntent.controllerInstanceId).getViewElement();
            nextView = Caviar.ControllersInstanceManager.get(nextIntent.controllerInstanceId).getViewElement();
            Caviar.UITransitions.transitionIn(currentView, nextView, nextIntent.transition, cb);
        }
        UIManager.transitionIn = transitionIn;
        /**
         * Transition out between controllers
         * @param  {Function} callback Transition end callback
         * @return {void}
         */
        function transitionOut(activeIntent, prevIntent, callback) {
            var cb = callback || function () {
            }, currentView, prevView;
            currentView = Caviar.ControllersInstanceManager.get(activeIntent.controllerInstanceId).getViewElement();
            prevView = Caviar.ControllersInstanceManager.get(prevIntent.controllerInstanceId).getViewElement();
            Caviar.UITransitions.transitionOut(currentView, prevView, activeIntent.transition, cb);
        }
        UIManager.transitionOut = transitionOut;
        /**
         * Change controller without transition
         * @param  {Function} callback
         * @return {void}
         */
        function transitionNone(activeIntent, nextIntent, callback) {
            var currentViewClassList, nextViewClassList;
            if (activeIntent) {
                currentViewClassList = Caviar.ControllersInstanceManager.get(activeIntent.controllerInstanceId).getViewElement().classList;
                currentViewClassList.remove('caviar-active');
                currentViewClassList.add('caviar-backgrounded');
                currentViewClassList.add('caviar-hidden');
            }
            nextViewClassList = Caviar.ControllersInstanceManager.get(nextIntent.controllerInstanceId).getViewElement().classList;
            nextViewClassList.remove('caviar-next');
            nextViewClassList.add('caviar-active');
            if (Caviar.isFunction(callback)) {
                callback();
            }
        }
        UIManager.transitionNone = transitionNone;
    })(UIManager = Caviar.UIManager || (Caviar.UIManager = {}));
})(Caviar || (Caviar = {}));

/// <reference path="Config.ts" />
var Caviar;
(function (Caviar) {
    var _storage, VERSION;
    // App version
    VERSION = Caviar.Config.get('version');
    // localStorage polyfill
    _storage = window.localStorage || {
        setItem: function (key, value) {
            this[key] = value;
        },
        getItem: function (key) {
            return this[key];
        },
        removeItem: function (key) {
            delete this[key];
        }
    };
    /**
     * Versioned cache for layout files
     * @module Caviar.LayoutCache
     * @author Bruno Ziiê <http://github.com/brunoziie/>
     */
    var LayoutCache;
    (function (LayoutCache) {
        /**
         * Get a layout from cache
         * @param  {String} key Layout path
         * @return {String}
         */
        function get(key) {
            var path = VERSION + '_' + key;
            return _storage.getItem(path);
        }
        LayoutCache.get = get;
        /**
         * Add or override a layout into cache
         * @param {String} key   Layout path
         * @param {String} value Layout content
         */
        function set(key, value) {
            var path = VERSION + '_' + key;
            return _storage.setItem(path, value);
        }
        LayoutCache.set = set;
        /**
         * Remove a layout from cache
         * @param  {String} key Layout path
         * @return {void}
         */
        function forget(key) {
            var path = VERSION + '_' + key;
            return _storage.removeItem(path);
        }
        LayoutCache.forget = forget;
        /**
         * Check if a layout already exists into cache
         * @param  {String}  key Layout path
         * @return {Boolean}
         */
        function has(key) {
            var path = VERSION + '_' + key;
            return _storage[path] !== undefined;
        }
        LayoutCache.has = has;
    })(LayoutCache = Caviar.LayoutCache || (Caviar.LayoutCache = {}));
})(Caviar || (Caviar = {}));

/// <reference path="View.ts" />
/// <reference path="LayoutCache.ts" />
var Caviar;
(function (Caviar) {
    /**
     * Load and caches layout files
     * @module Caviar.LayoutLoader
     * @author Bruno Ziiê <http://github.com/brunoziie/>
     */
    var LayoutLoader;
    (function (LayoutLoader) {
        var ViewsCache = {};
        /**
         * Convert a controller name to layout filename
         * @param  {String} str Controller name
         * @return {String}     Layout filename
         */
        function controllerNameToLayout(str) {
            return str.replace('Controller', '').replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase();
        }
        LayoutLoader.controllerNameToLayout = controllerNameToLayout;
        /**
         * Parses the layout of the controller and loads it
         * @param  {String}   controllerName Controller name
         * @param  {Function} callback       Callback
         * @param  {Function} callback.view  View object
         */
        function load(controllerName, callback) {
            var filename;
            filename = controllerNameToLayout(controllerName);
            return this.getViewObject(filename, callback);
        }
        LayoutLoader.load = load;
        /**
         * Preloads a layout
         * @param  {String} layoutName Layout filename without extension
         *                             or controller name
         * @return {void}
         */
        function preload(layoutName) {
            var filename;
            filename = (layoutName.indexOf('Controller') > 0) ? controllerNameToLayout(layoutName) : layoutName;
            if (ViewsCache[filename]) {
                return;
            }
            return this.getLayoutFile(filename, function (data) {
                var view = new Caviar.View(data);
                ViewsCache[filename] = view;
            });
        }
        LayoutLoader.preload = preload;
        /**
         * Parse a layout as a View object
         * @param  {String}   filename      Layout path
         * @param  {Function} callback      Callback
         * @param  {Object}   callback.view Parsed View object
         * @return {void}
         */
        function getViewObject(filename, callback) {
            if (ViewsCache[filename]) {
                return callback(ViewsCache[filename]);
            }
            this.getLayoutFile(filename, function (data) {
                var view = new Caviar.View(data);
                ViewsCache[filename] = view;
                return callback(view);
            });
        }
        LayoutLoader.getViewObject = getViewObject;
        /**
         * Request a layout file
         * @param  {String}   filename      Filename without .html extension
         * @param  {Function} callback      Callback
         * @param  {Function} callback.data Layout content
         */
        function getLayoutFile(filename, callback) {
            var debuggable = Caviar.Config.get('debug'), xmlhttp, path;
            if (Caviar.runningOnWP()) {
                // Request for local path requires a special path when running
                // on Windows Phone 8 WebView
                path = "x-wmapp0:www/views/" + filename + ".html";
            }
            else {
                path = "views/" + filename + ".html";
            }
            if (!debuggable && Caviar.LayoutCache.has(path)) {
                return callback(Caviar.LayoutCache.get(path));
            }
            xmlhttp = new XMLHttpRequest();
            xmlhttp.onreadystatechange = function () {
                if (xmlhttp.readyState === 4) {
                    if (!Caviar.Config.get('debug')) {
                        Caviar.LayoutCache.set(path, xmlhttp.responseText);
                    }
                    return callback(xmlhttp.responseText);
                }
            };
            xmlhttp.open("GET", path, true);
            xmlhttp.send();
            return;
        }
        LayoutLoader.getLayoutFile = getLayoutFile;
    })(LayoutLoader = Caviar.LayoutLoader || (Caviar.LayoutLoader = {}));
})(Caviar || (Caviar = {}));

/// <reference path="Caviar.ts" />
/// <reference path="defs/CaviarViewEventListener.ts" />
var Caviar;
(function (Caviar) {
    /**
     * Controller superclass.
     * This class will be used like a basic implementation that all controllers must to be
     * @module Caviar
     * @class Controller
     * @author Bruno Ziiê <http://github.com/brunoziie/>
     */
    var Controller = (function () {
        function Controller() {
            /**
             * Events listeners from view.
             * @type {Array<CaviarViewEventListener>}
             */
            this.eventListeners = [];
            /**
             * Controller name
             * @type {String}
             */
            this.name = null;
            /**
             * View element
             * @type {Object}
             */
            this.view = null;
            /**
             * Store data used by controller
             * @type {Object}
             */
            this.data = null;
        }
        /**
         * Get a data stored on controller instance
         * @param  {String} key
         */
        Controller.prototype.get = function (key) {
            return this.data[key];
        };
        /**
         * Add/Update a data on controller
         * @param {String} key
         * @param {Mixed} value
         */
        Controller.prototype.set = function (key, value) {
            this.data[key] = value;
        };
        /**
         * Callback executed before call initialize method
         * @param {Object} intent The intent that generated the current instance
         * @return {void}
         */
        Controller.prototype.beforeInitialize = function (intent) {
            return;
        };
        /**
         * Init controller's settings
         * @param {Object} intent The intent that generated the current instance
         * @return {void}
         */
        Controller.prototype.initialize = function (intent) {
            return;
        };
        /**
         * Callback called when a controller instance back to front
         * @param {Any} data Data sent by method onLeave from controller that was actived
         */
        Controller.prototype.onResume = function (data) {
            return;
        };
        /**
         * Callback called when user back to previous controller instance
         */
        Controller.prototype.onLeave = function () {
            return;
        };
        /**
         * Callback called when a controller instance receives data from another
         * @param {Object} data Data sent by previous controller instance
         */
        Controller.prototype.onResult = function (data) {
            return;
        };
        /**
         * Get DOM element binded by controller
         */
        Controller.prototype.getViewElement = function () {
            return this.view.getElement();
        };
        /**
         * Set event listeners on view
         * @param  {String}   event    Event name
         * @param  {String}   selector Element selector
         * @param  {Function} callback Callback
         * @return {void}
         */
        Controller.prototype.listen = function (event, selector, callback) {
            var view = this.getViewElement(), cb;
            cb = function (e) {
                if (Caviar.matchSelector(e.target, selector)) {
                    callback();
                }
            };
            view.addEventListener(event, cb, false);
            this.eventListeners.push({
                event: event,
                callback: cb
            });
        };
        /**
         * Remove all event listeners defined
         * @return {void}
         */
        Controller.prototype.destroyEventListeners = function () {
            var view = this.getViewElement(), len = this.eventListeners.length, x, cur;
            for (x = 0; x < len; x += 1) {
                cur = this.eventListeners[x];
                view.removeEventListener(cur.event, cur.callback, false);
            }
        };
        /**
         * Destroy controller's resources
         * @return {void}
         */
        Controller.prototype.destroy = function () {
            this.data = {};
            return;
        };
        return Controller;
    })();
    Caviar.Controller = Controller;
})(Caviar || (Caviar = {}));

/// <reference path="App.ts" />
/// <reference path="UIManager.ts" />
/// <reference path="LayoutLoader.ts" />
/// <reference path="Controller.ts" />
var Caviar;
(function (Caviar) {
    /**
     * Manages instances and resources from controllers
     * @module Caviar.ControllersInstanceManager
     * @author Bruno Ziiê <http://github.com/brunoziie/>
     */
    var ControllersInstanceManager;
    (function (ControllersInstanceManager) {
        var colletion, getSequence, seq;
        seq = 0;
        /**
         * Store all controller instances
         * @type {Object}
         */
        colletion = {};
        /**
         * Create a id for every single instance
         * @return {String}
         */
        getSequence = function () {
            seq += 1;
            return "uid" + seq;
        };
        /**
         * Checks if a controller instance exists
         * @param {string} key Instance Id
         */
        function exists(key) {
            return colletion[key] !== undefined;
        }
        ControllersInstanceManager.exists = exists;
        /**
         * Get a controller instance by id
         * @param  {String} key Instance id
         * @return {Mixed}      Object when is a valid id or null if isn't a valid id
         */
        function get(key) {
            return colletion[key] || null;
        }
        ControllersInstanceManager.get = get;
        /**
         * Create a new controller instance
         * @param  {Object}   intent   Intent
         * @param  {Function} callback
         * @return {void}
         */
        function create(intent, callback) {
            var that = this, controllerName, instance, sequence = getSequence(), controllerName = intent.controller;
            // Create a generic controller instance for invalid controller classes.
            // This can be useful when you want to create a page that does not need a controller.
            instance = (App[controllerName]) ? new App[controllerName] : new Caviar.Controller;
            instance.name = controllerName;
            instance.data = {};
            intent.controllerInstanceId = sequence;
            if (instance.beforeInitialize) {
                instance.beforeInitialize(intent);
            }
            return that.loadResources(instance, function (viewObj) {
                instance.view = Caviar.UIManager.addViewToStage(viewObj, instance.data);
                instance.initialize(intent);
                colletion[sequence] = instance;
                return callback(sequence);
            });
        }
        ControllersInstanceManager.create = create;
        /**
         * Load controller resources
         * @param {Object} Controller instance
         * @param {Function} callback
         * @return {void}
         */
        function loadResources(instance, callback) {
            return Caviar.LayoutLoader.load(instance.name, callback);
        }
        ControllersInstanceManager.loadResources = loadResources;
        /**
         * Destroy data and resources created by controller
         * @return {void}
         */
        function unloadResources(instance) {
            var el = instance.getViewElement();
            el.parentNode.removeChild(el);
        }
        ControllersInstanceManager.unloadResources = unloadResources;
        /**
         * @TODO
         * Restore a destroyed view
         */
        function restore(controllerInstance, callback) {
            // code
        }
        ControllersInstanceManager.restore = restore;
        /**
         * Destroy a controller instance and your resources
         * @param  {String} key Instance id
         */
        function destroy(key) {
            var controllerInstance;
            controllerInstance = this.get(key);
            controllerInstance.destroyEventListeners();
            controllerInstance.destroy();
            this.unloadResources(controllerInstance);
            delete colletion[key];
        }
        ControllersInstanceManager.destroy = destroy;
    })(ControllersInstanceManager = Caviar.ControllersInstanceManager || (Caviar.ControllersInstanceManager = {}));
})(Caviar || (Caviar = {}));

/// <reference path="Caviar.ts" />
/// <reference path="Intent.ts" />
/// <reference path="IntentHistory.ts" />
/// <reference path="ControllersInstanceManager.ts" />
/// <reference path="defs/jquery/jquery.d.ts" />
var Caviar;
(function (Caviar) {
    /**
     * Manages intents
     * @module Caviar.IntentManager
     * @author Bruno Ziiê <http://github.com/brunoziie/>
     */
    var IntentManager;
    (function (IntentManager) {
        var INDEX = 0, CURRENT_INDEX = 0, StateHistory = History, resultData = null, beforeStartIntentEvents = [], onBackEvents = [], processEventsStack;
        processEventsStack = function (stack) {
            var len = stack.length, x, cur, hasFailed = false;
            for (x = 0; x < len; x += 1) {
                cur = stack[x];
                if (cur() === false) {
                    hasFailed = true;
                }
            }
            return !hasFailed;
        };
        /**
         * Create a id to identify all single intent on hash url
         * @return {Integer}
         */
        function getIndex() {
            return (INDEX += 1);
        }
        IntentManager.getIndex = getIndex;
        /**
         * Set result data
         * @param {Mixed} data
         */
        function setResult(data) {
            resultData = data;
        }
        IntentManager.setResult = setResult;
        /**
         * Get result data
         * @return {Mixed}
         */
        function getResult() {
            return resultData;
        }
        IntentManager.getResult = getResult;
        /**
         * Clean result data
         * @return {void}
         */
        function clearResult() {
            resultData = null;
        }
        IntentManager.clearResult = clearResult;
        /**
         * Set a callback to be called before start a intent.
         * @param {Function} callback
         */
        function beforeStartIntent(callback) {
            beforeStartIntentEvents.push(callback);
        }
        IntentManager.beforeStartIntent = beforeStartIntent;
        /**
         * Set a callback to be called when press backbutton or a 'caviar-back' element
         * @param {Function} callback
         */
        function onBack(callback) {
            onBackEvents.push(callback);
        }
        IntentManager.onBack = onBack;
        /**
         * Bind events from intents
         */
        function bindIntentElements() {
            var $doc;
            $doc = $(document);
            StateHistory.Adapter.bind(window, 'statechange', function () {
                var currentIndex, prevIndex, state;
                state = StateHistory.getState();
                prevIndex = CURRENT_INDEX;
                currentIndex = state.data.index || 0;
                if (prevIndex > currentIndex) {
                    IntentManager.back();
                }
                CURRENT_INDEX = currentIndex;
            });
            document.addEventListener('backbutton', function (e) {
                if (!processEventsStack(onBackEvents)) {
                    e.preventDefault();
                }
            }, false);
            $doc.on('tap', '.caviar-back', function (e) {
                StateHistory.back();
                e.preventDefault();
            });
            $doc.on('tap', '[intent]', function (e) {
                var that = this;
                if (!Caviar.Menu.isOpened()) {
                    IntentManager.start(new Caviar.Intent(that), null);
                }
                else {
                    setTimeout(function () {
                        IntentManager.start(new Caviar.Intent(that), null);
                    }, 200);
                    Caviar.Menu.hide();
                }
                e.preventDefault();
            });
        }
        IntentManager.bindIntentElements = bindIntentElements;
        /**
         * Starts a intent
         * @param {Object} intent
         * @param {Function} callback
         */
        function start(intent, callback) {
            var currentIntent, nextIntent = intent;
            Caviar.IntentHistory.add(nextIntent);
            // Create a new controller instance and load all resources
            Caviar.ControllersInstanceManager.create(nextIntent, function (instanceId) {
                if (Caviar.IntentHistory.hasPrev()) {
                    currentIntent = Caviar.IntentHistory.getPrev();
                    Caviar.UIManager.transitionIn(currentIntent, nextIntent, function () {
                        var index = IntentManager.getIndex();
                        StateHistory.pushState({ index: index }, null, '?state=' + index);
                        if (Caviar.isFunction(callback)) {
                            callback();
                        }
                        return IntentManager.clearStack(nextIntent);
                    });
                }
                else {
                    // Start controller without transitions
                    Caviar.UIManager.transitionNone(undefined, nextIntent, function () {
                        if (Caviar.isFunction(callback)) {
                            callback();
                        }
                    });
                }
            });
        }
        IntentManager.start = start;
        /**
         * Back to previous intent
         */
        function back() {
            var current, controllerInstance, activeControllerInstance, prev;
            if (Caviar.IntentHistory.hasPrev()) {
                current = Caviar.IntentHistory.getCurrent();
                prev = Caviar.IntentHistory.getPrev();
                controllerInstance = Caviar.ControllersInstanceManager.get(prev.controllerInstanceId);
                activeControllerInstance = Caviar.ControllersInstanceManager.get(prev.controllerInstanceId);
                controllerInstance.onResume(activeControllerInstance.onLeave());
                if (this.getResult() !== null) {
                    controllerInstance.onResult(this.getResult());
                    this.clearResult();
                }
                var last = Caviar.IntentHistory.removeLast();
                Caviar.UIManager.transitionOut(current, prev, function () {
                    Caviar.ControllersInstanceManager.destroy(last.controllerInstanceId);
                });
            }
            else {
                // Close application when have no more instances to back
                // Its requires Cordova script included
                Caviar.exit();
            }
        }
        IntentManager.back = back;
        /**
         * Back to previous intent passing data
         * @param {Mixed} data
         * @todo: review it, may cause error.
         */
        function result(data) {
            this.setResult(data);
            StateHistory.back();
        }
        IntentManager.result = result;
        /**
         * When start a intent with main controller destroy all previous controller instances.
         * This happens because understand that if the User back to the main screen of the application
         * it will not have the intention to return to the previous screen.
         * @param  {Object} intent Started intent
         * @todo Enable to call using controllers differents of MainController
         */
        function clearStack(intent) {
            var all, count, current, x, len, cIntent;
            if (intent.controller === 'MainController') {
                current = Caviar.IntentHistory.getCurrent();
                all = Caviar.IntentHistory.all();
                count = all.length;
                len = count - 1;
                for (x = 0; x < len; x += 1) {
                    cIntent = all[x];
                    Caviar.ControllersInstanceManager.destroy(cIntent.controllerInstanceId);
                }
                Caviar.IntentHistory.clear();
                Caviar.IntentHistory.add(current);
            }
        }
        IntentManager.clearStack = clearStack;
    })(IntentManager = Caviar.IntentManager || (Caviar.IntentManager = {}));
})(Caviar || (Caviar = {}));

/// <reference path="Config.ts" />
/// <reference path="IntentManager.ts" />
/// <reference path="defs/cordova/cordova.d.ts" />
var Caviar;
(function (Caviar) {
    /**
     * Execute steps to start the application
     * @module Caviar.Bootstrap
     * @author Bruno Ziiê <http://github.com/brunoziie/>
     */
    var Bootstrap;
    (function (Bootstrap) {
        var onDeviceReady, getNavigatorObject, processCallbacksStack, onApplicationStartCallbacks = [];
        /**
         * Wrapper to avoid TypeScript error
         */
        getNavigatorObject = function () {
            return navigator;
        };
        /**
         * Runs all callback registered for app startup
         * @return {void}
         */
        processCallbacksStack = function () {
            var len = onApplicationStartCallbacks.length, x, cur;
            for (x = 0; x < len; x += 1) {
                cur = onApplicationStartCallbacks[x];
                cur();
            }
        };
        /**
         * onDeviceReady callback
         * @return {void}
         */
        onDeviceReady = function () {
            var nav = getNavigatorObject();
            processCallbacksStack();
            Caviar.IntentManager.start(new Caviar.Intent('main'), function () {
                document.body.classList.add('resolved');
                if (typeof nav.splashscreen !== 'undefined') {
                    nav.splashscreen.hide();
                }
            });
        };
        /**
         * Bootup application
         * @param {Object} configs Application configs
         * @return {void}
         */
        function bootup(configs) {
            var that = this;
            Caviar.Config.set(configs, undefined);
            if (typeof cordova !== 'undefined') {
                document.addEventListener("deviceready", function () {
                    onDeviceReady();
                }, false);
            }
            else {
                onDeviceReady();
            }
            Caviar.IntentManager.bindIntentElements();
        }
        Bootstrap.bootup = bootup;
        /**
         * Register a startup application callback
         * @param {Function} callback
         * @return {void}
         */
        function onApplicationStart(callback) {
            onApplicationStartCallbacks.push(callback);
        }
        Bootstrap.onApplicationStart = onApplicationStart;
    })(Bootstrap = Caviar.Bootstrap || (Caviar.Bootstrap = {}));
})(Caviar || (Caviar = {}));

/// <reference path="defs/jquery/jquery.d.ts" />
var Caviar;
(function (Caviar) {
    /**
     * XHR module
     * @todo Implements methods get and post without uses jQuery
     * @module Caviar.HTTP
     * @author Bruno Ziiê <http://github.com/brunoziie/>
     */
    var HTTP;
    (function (HTTP) {
        /**
         * Alias to jQuery $.get
         * @type {Function}
         */
        HTTP.get = $.get;
        /**
         * Alias to jQuery $.post
         * @type {Function}
         */
        HTTP.post = $.post;
    })(HTTP = Caviar.HTTP || (Caviar.HTTP = {}));
})(Caviar || (Caviar = {}));

/// <reference path="../../core/Config.ts" />
/// <reference path="../../core/Bootstrap.ts" />
/// <reference path="../../core/defs/jquery/jquery.d.ts" />
/// <reference path="snap.d.ts" />
var Caviar;
(function (Caviar) {
    /**
     * Manages application side menu
     * @module Caviar.Menu
     * @author Bruno Ziiê <http://github.com/brunoziie/>
     */
    var Menu;
    (function (Menu) {
        var $doc = $(document), snapper;
        /**
         * Create a menu instance
         * @param  {Object} options Snap.js options
         * @return {void}
         */
        function create(options) {
            var opt = options || {
                element: document.querySelector('.snap-content'),
                disable: 'right',
                transitionSpeed: 0.19
            };
            snapper = new Snap(opt);
            return this.bindElements();
        }
        Menu.create = create;
        /**
         * Bind controls menu elements
         * @return {void}
         */
        function bindElements() {
            var self = this;
            $doc.on('tap', '.caviar-open-menu-left', function (e) {
                self.show('left');
                e.preventDefault();
            });
            $doc.on('tap', '.caviar-open-menu-right', function (e) {
                self.show('right');
                e.preventDefault();
            });
            $doc.on('tap', '.caviar-toggle-menu-left', function (e) {
                self.toggle('left');
                e.preventDefault();
            });
            $doc.on('tap', '.caviar-toggle-menu-right', function (e) {
                self.toggle('right');
                e.preventDefault();
            });
            $doc.on('tap', '.caviar-menu-close', function (e) {
                self.hide();
                e.preventDefault();
            });
            $doc.on('tap', '.intent', function (e) {
                self.hide();
                e.preventDefault();
            });
            document.addEventListener('backbutton', function () {
                self.hide();
            }, false);
            return;
        }
        Menu.bindElements = bindElements;
        /**
         * Hide sidebar menu
         * @return {void}
         */
        function hide() {
            if (snapper !== undefined) {
                return snapper.close();
            }
        }
        Menu.hide = hide;
        /**
         * Show sidebar menu
         * @param  {String} side Side of menu (left, right)
         * @return {void}
         */
        function show(side) {
            if (snapper !== undefined) {
                return snapper.open(side);
            }
        }
        Menu.show = show;
        /**
         * Toggle sidebar menu
         * @param  {String} side Side of menu (left, right)
         * @return {void}
         */
        function toggle(side) {
            if (snapper !== undefined) {
                (snapper.state().state === 'closed') ? this.show(side) : this.hide();
            }
        }
        Menu.toggle = toggle;
        /**
         * Check if sidebar menu is opened
         * @return {Boolean}
         */
        function isOpened() {
            if (snapper !== undefined) {
                return snapper.state().state !== 'closed';
            }
            return false;
        }
        Menu.isOpened = isOpened;
    })(Menu = Caviar.Menu || (Caviar.Menu = {}));
})(Caviar || (Caviar = {}));
Caviar.Bootstrap.onApplicationStart(function () {
    if (Caviar.Config.get('hasSidebarMenu')) {
        return Caviar.Menu.create({
            element: $('.snap-content')[0],
            disable: 'right',
            transitionSpeed: 0.2
        });
    }
});
